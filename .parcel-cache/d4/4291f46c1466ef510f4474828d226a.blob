var _parcelHelpers = require("@parcel/transformer-js/lib/esmodule-helpers.js");
_parcelHelpers.defineInteropFlag(exports);
var _TileJs = require('./Tile.js');
var _TileJsDefault = _parcelHelpers.interopDefault(_TileJs);
var _RoadJs = require('./Road.js');
var _RoadJsDefault = _parcelHelpers.interopDefault(_RoadJs);
var _BuildingJs = require('./Building.js');
var _BuildingJsDefault = _parcelHelpers.interopDefault(_BuildingJs);
class Field {
  constructor(rows, cols) {
    this.rows = rows;
    this.cols = cols;
    this.matrix = {};
    this.buildQueue = [];
    for (let i = 0; i < this.rows; i++) {
      this.matrix[i] = {};
      for (let j = 0; j < this.cols; j++) {
        this.matrix[i][j] = new _TileJsDefault.default(i, j, null);
      }
    }
  }
  handleTileClick(row, col, event) {
    let newTile = null;
    switch (event.tool) {
      case 'road':
        newTile = new _RoadJsDefault.default(row, col, null);
        break;
      case 'eraser':
        newTile = new _TileJsDefault.default(row, col, null);
        break;
      default:
        newTile = new _BuildingJsDefault.default(row, col, event.tool);
    }
    const neighbors = this.getNeighbors(newTile);
    this.updateFieldTile(newTile);
    this.updateFieldTile(neighbors.top);
    this.updateFieldTile(neighbors.bottom);
    this.updateFieldTile(neighbors.left);
    this.updateFieldTile(neighbors.right);
  }
  updateFieldTile(tile) {
    if (tile !== null) {
      const row = tile.getRow();
      const col = tile.getCol();
      const oldTexture = this.getTile(row, col).getTextureName();
      const neighbors = this.getNeighbors(tile);
      tile.updateSelfBasedOnNeighbors(neighbors);
      if (tile.getTextureName() !== oldTexture) {
        this.setTile(row, col, tile);
        this.buildQueue.push(tile);
      }
    }
  }
  getNeighbors(tile) {
    const row = tile.getRow();
    const col = tile.getCol();
    const neighbors = {
      top: this.isValidPosition(row - 1, col) ? this.getTile(row - 1, col) : null,
      bottom: this.isValidPosition(row + 1, col) ? this.getTile(row + 1, col) : null,
      left: this.isValidPosition(row, col - 1) ? this.getTile(row, col - 1) : null,
      right: this.isValidPosition(row, col + 1) ? this.getTile(row, col + 1) : null
    };
    return neighbors;
  }
  isValidPosition(row, col) {
    const isRowValid = row >= 0 && row < this.getRows();
    const isColValid = col >= 0 && col < this.getCols();
    return isRowValid && isColValid;
  }
  iterateBuildQueue(callback) {
    while (this.buildQueue.length > 0) {
      const tile = this.buildQueue.shift();
      callback(tile);
    }
  }
  getTile(row, col) {
    return this.matrix[row][col];
  }
  setTile(row, col, tile) {
    this.matrix[row][col] = tile;
  }
  getBuildQueue() {
    return this.buildQueue;
  }
  getRows() {
    return this.rows;
  }
  getCols() {
    return this.cols;
  }
}
exports.default = Field;
